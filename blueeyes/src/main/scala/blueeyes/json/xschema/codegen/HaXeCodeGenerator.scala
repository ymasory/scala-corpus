package blueeyes.json.xschema.codegen

import _root_.blueeyes.json.JsonParser
import _root_.blueeyes.json.JsonAST._
import _root_.blueeyes.json.Printer._
import _root_.blueeyes.json.xschema._
import _root_.blueeyes.json.xschema.XSchemaTree._
import _root_.blueeyes.json.xschema.Serialization._

import java.io.{Writer}


object HaXeCodeGenerator extends CodeGeneratorCLI {
  val generator = new BaseHaXeCodeGenerator
}

class BaseHaXeCodeGenerator extends CodeGenerator with CodeGeneratorHelpers {
  def generate(root: XRoot, destPathCode: String, destPathTests: String, namespaceSpec: List[String], writerF: String => Writer) = {
    val includeSchemas = extractBoolProperty(root.properties, PredefinedProperties.XSchemaIncludeSchemas, true)

    val bundle      = CodeBundle.empty
    val testBundle  = CodeBundle.empty

    implicit val database = XSchemaDatabase(root.definitions, root.constants)

    val namespaces  = (if (namespaceSpec.length == 0) database.namespaces else namespaceSpec)

    for (namespace <- namespaces) {
      val code = CodeBuilder.empty
      val test = CodeBuilder.empty

      buildCodeFor(namespace, code, root, includeSchemas)
      buildTestFor(namespace, test, root, includeSchemas)

      bundle += toFile(namespace, "Data", "hx")         -> code
      testBundle += toFile(namespace, "DataTest", "hx") -> test
    }

    bundle.create(destPathCode, writerF)
    testBundle.create(destPathTests, writerF)
  }

  private def extractBoolProperty(map: Map[String, JValue], prop: String, default: Boolean) = map.get(prop) match {
    case None => false
    case Some(v) => v match {
      case JBool(b) => b
      case x => error("Expected bool but found: " + x)
    }
  }

  private def extractListProperty(map: Map[String, JValue], prop: String): List[String] = map.get(prop) match {
    case None => Nil

    case Some(v) => v match {
      case JArray(list) => list.flatMap {
        case JString(s) => s :: Nil
        case x => error("Expected array of strings for " + prop + " property but found: " + x)
      }

      case JString(item) => item :: Nil

      case _ => error("Expected string or array of strings for " + prop + " property")
    }
  }

  private def buildCodeFor(namespace: String, code: CodeBuilder, root: XRoot, includeSchemas: Boolean)(implicit database: XSchemaDatabase): Unit = {
    code.addln("// This code was auto-generated by Lift Json XSchema - do not edit").
         addln("// Note: Requires the Stax standard library for HaXe")

    code.add("""
      package ${namespace};

      import Type;
      import Prelude;
      import PreludeExtensions;
      import PreludeExtensions;
      import haxe.text.json.JValue;
      import haxe.data.transcode.Transcode;
      import haxe.data.transcode.TranscodeJValueExtensions;
      import haxe.data.transcode.TranscodeJValue;
      import haxe.data.collections.Set;
      import haxe.data.collections.Map;
      import haxe.data.collections.List;
      """ +

      database.definitions.filter(_.namespace != namespace).map("import " + _.namespace + ".Data;").distinct.mkString("\n") +

      """
      using PreludeExtensions;
      using haxe.text.json.JValueExtensions;
      using haxe.data.transcode.TranscodeJValueExtensions;
      using haxe.data.transcode.TranscodeJValue;
      using ${namespace}.Data;
      """ +

      database.definitions.filter(_.namespace != namespace).map("using " + _.namespace + ".Data;").distinct.mkString("\n") +

      """

      class Utils{
        public static function compareObjects<T>(v1 : T, v2 : T, order: Array<Dynamic>): Int {
          var index1 = Utils.indexOf(v1, order);
          var index2 = Utils.indexOf(v2, order);

          return if (index1 == index2) Stax.getOrderForType(Type.typeof(v1))(v1, v2);
                 else if (index1 > index2) 1
                 else -1;
        }
        static function indexOf<T>(v : T, order: Array<Dynamic>): Int {
          var index = 0;

          for (type in order) {
            if (v.isInstanceOf(type)) return index;

            ++index;
          }

          return throw ("Type cannot be found for value: " + v); return -1;
        }
        public static function extract<T>(namespace: String, v: JValue, defaultValue: JValue): T {
          try {
            return v.extractImplementation0(namespace);
          }
          catch (e: Dynamic) {
            return defaultValue.extractImplementation0(namespace);
          }
        }

        static function extractImplementation0<T>(v : JValue, namespace: String): T {
          var hash = v.extractHash();
          var keys = hash.keys();

          if (keys.hasNext()){
            var className = keys.next();
            var value     = hash.get(className);
            if (className.substr(0, 1) == "_") className = "A" + className;

            var clazz = Type.resolveClass(namespace + "." + className);
            return cast Reflect.callMethod(clazz, Reflect.field(clazz, "extract"), [value]);
          }
          else Stax.error("Implementation cannot be extracted."); return null;
        }

        public static function decompose<T>(t : T): JValue {
          var className = Utils.classShortName(t);
          if (className.substr(0, 2) == "A_") className = className.substr(0, 1);
          return JObject([JField(className, TranscodeJValue.getDecomposerFor(Type.typeof(t))(t))]);
        }
        static function classShortName<T>(t : T): String{
          switch(Type.typeof(t))
          {
            case TClass(c): {
              var name  = Type.getClassName(c);
              var index = name.lastIndexOf(".");
              return if (index != -1) name.substr(index + 1);
              else name;
            }
            default: Stax.error("Value is not class. Value: " + t); return null;
          }
        }
        public static function typeName<T>(v: T): String{
          var type = Type.typeof(v);
          return switch (type){
            case TClass(c):
                "TClass(" +  Type.getClassName(c) + ")";
            case TEnum(e):
                "TEnum(" +  Type.getEnumName(e) + ")";
            default:
              Std.string(type);
          }
        }
      }

      class AbstractDataObject<T>{
        private var order: OrderFunction<T>;
        public function new(?order: OrderFunction<T>){
          this.order = order;
        }
        public function toString(): String {
          return Stax.getShowForType(Type.typeof(this))(this);
        }
        public function hashCode(): Int {
          return Stax.getHashForType(Type.typeof(this))(this);
        }
        public function compare(v2: T): Int {
          return if (Utils.typeName(this) == Utils.typeName(v2)) Stax.getOrderForType(Type.typeof(this))(this, cast v2) else order(cast this, v2);
        }
        public function equals(v2: T): Bool {
          return if (Utils.typeName(this) == Utils.typeName(v2)) Stax.getEqualForType(Type.typeof(this))(this, cast v2) else false;
        }
      }

      class AbstractSingletonDataObject<T> extends AbstractDataObject<T>{
        public function new(?order: OrderFunction<T>){
          super(order);
        }
        public function decompose(): JValue {
          return JObject([]);
        }
      }
      """
      ,

      "namespace" -> namespace
    ).newline(2)

    code.newline(2)

    code.join(database.definitionsIn(namespace), code.newline.newline) { definition =>
      buildDataFor(namespace, definition, code, includeSchemas)
    }

    buildConstantsFor(namespace, code)
  }

  private def buildTestFor(namespace: String, code: CodeBuilder, root: XRoot, includeSchemas: Boolean)(implicit database: XSchemaDatabase): Unit = {
    code.addln("// These tests were auto-generated by Lift Json XSchema - do not edit").
         addln("// Note: Requires the Stax standard library for HaXe")

    code.using("namespace" -> namespace, "package" -> namespace) {
      code.add("""
        package ${namespace};

        import Prelude;
        import haxe.test.TestCase;
        import haxe.test.Assert;
        import haxe.text.json.JValue;
        import haxe.data.transcode.Transcode;
        import haxe.data.transcode.TranscodeJValue;
        import haxe.data.collections.Set;
        import haxe.data.collections.Map;
        import haxe.data.collections.List;
        import ${namespace}.Data;

        using Prelude;
        using PreludeExtensions;
        using haxe.text.json.JValue;
        using haxe.data.transcode.TranscodeJValueExtensions;
        using ${namespace}.Data;

      """).newline

      buildSerializationTestFor(namespace, code, root, includeSchemas)
    }
  }

  private def buildSerializationTestFor(namespace: String, code: CodeBuilder, root: XRoot, includeSchemas: Boolean)(implicit database: XSchemaDatabase): Unit = {
    // For every product we generate some test data constructed by
    // deserializing the product from nothing:

    code.newline.add("class ExampleProductData ").block {
      code.join(database.productsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo), "extractor" -> getExtractorFor(defn.referenceTo)) {
          code.add("public static var Example${name}: ${type} = ${type}.extract(JObject([]));")
        }
      }
    }

    // For every product, we test both serialization & deserialization (in basic ways):
   code.newline.add("class DataProductSerializationTest extends TestCase").block {

      code.join(database.productsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo)) {
          code.add("""
            public function testDeserializationOf${name}SucceedsEvenWhenInformationIsMissing() {
              Assert.equals(ExampleProductData.Example${name}.isInstanceOf(${type}), true);
            }""").newline

          if (defn.isSingleton) {
            code.add("""
              public function SerializationOf${name}HasNonZeroInformationContent() {
                Assert.notEquals(ExampleProductData.Example${name}.decompose(), JObject([]));
              }""")
          }
          else {
            code.add("""
              public function SerializationOf${name}HasNonZeroInformationContent() {
                Assert.notEquals(ExampleProductData.Example${name}.decompose(), JObject([]));
              }
            """)
          }
        }
      }
   }

    // For every multitype, we generate some test data constructed by
    // deserializing every product which is type-compatible with the multitype:
    code.newline.add("class ExampleMultitypeData ").block {
      code.join(database.coproductsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo)) {
          code.addln("""public static var Example${name}: ${type} = ${type}Extensions.extract(JObject([]));""")

          code.join(database.findProductTerms(defn), code.newline) { product =>
            code.add("""public static var Example${name}From${productName}: ${type} = ${type}Extensions.extract(JObject([JField("${productName}", ${productNamespace}.ExampleProductData.Example${productName}.decompose())]));""",
              "productName"      -> product.name,
              "productNamespace" -> product.namespace
            )
          }
        }
      }
    }
    code.newline(2)

    code.add("class DataCoproductSerializationTest extends TestCase ").block {
      code.join(database.coproductsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo)) {
          code.add("""
            public function testDeserializationOf${name}SucceedsEvenWhenInformationIsMissing() {
              Assert.equals(ExampleMultitypeData.Example${name}.isInstanceOf(${type}), true);
            }
            public function testSerializationOf${name}HasNonZeroInformationContent() {
              Assert.notEquals(${name}Extensions.decompose(ExampleMultitypeData.Example${name}), JObject([]));
            }
          """).newline

          code.join(database.findProductTerms(defn), code.newline) { product =>
            code.add("""
              public function testDeserializationOf${name}From${productName}Succeeds() {
                Assert.equals(ExampleMultitypeData.Example${name}From${productName}.isInstanceOf(${type}), true);
              }
              public function testSerializationOf${name}From${productName}HasNonZeroInformationContent() {
                Assert.notEquals(${name}Extensions.decompose(ExampleMultitypeData.Example${name}From${productName}), JObject([]));
              }""",
              "productName" -> product.name
            )
          }
        }
      }
    }

    code.newline(2)

    code.add("class DataConstantsSerializationTest extends TestCase").block {
      code.join(database.constantsIn(namespace), code.newline.newline) { constant =>
        code.add("""
          public function testDeserializationOfConstant${name}Succeeds() {
            Assert.equals(String.extract(Constants.${name}.decompose()), Constants.${name});
          }
          public function testSerializationOfConstant${name}HasNonZeroInformationContent() {
            Assert.notEquals(Constants.${name}.decompose(), JObject([]));
          }
        """,
        "name" -> constant.name,
        "type" -> typeSignatureOf(constant.constantType)
        )
      }
    }
  }

  private def formCompleteExtensionClause(clazz: Option[String], interfaces: List[String]) = {
    val initial = clazz.map("extends " + _)
    interfaces match {
      case Nil => initial.getOrElse(" ")
      case xs =>  initial.map(_ + ", ").getOrElse("") + "implements " + xs.mkString(", implements ") + " "
    }
  }

  private def buildDataFor(namespace: String, definition: XDefinition, code: CodeBuilder, includeSchemas: Boolean)(implicit database: XSchemaDatabase): Unit = {
    def buildMultitypeTypeclasses(x: XMultitype) = {
      var leafTerms    = database.referencesOf(database.findLeafTerms(x))

      code.add("""
        public static function compare(v1 : ${type}, v2 : ${type}): Int {
          return Utils.compareObjects(v1, v2, [${orderCode}]);
        }
        public static function equals(v1 : ${type}, v2 : ${type}): Bool {
          return if (Utils.typeName(v1) == Utils.typeName(v2)) Stax.getEqualForType(Type.typeof(v1))(v1, v2) else false;
        }
        public static function toString(v : ${type}): String {
          return Stax.getShowForType(Type.typeof(v))(v);
        }
        public static function hashCode(v : ${type}): Int {
          return Stax.getHashForType(Type.typeof(v))(v);
        }
        public static function extract(v: JValue): ${type} {
          return Utils.extract("${namespace}", v, ${defJson});
        }
        public static function decompose(v : ${type}): JValue {
          return Utils.decompose(v);
        }""",
        "typeclassBindType" -> (if (x.isInstanceOf[XUnion]) "" else "c: Class<${type}>, "),

        "typeclassBindValue" -> (if (x.isInstanceOf[XUnion]) "" else "${type}"),

        "defJson" -> renderHaXe(x.default),

        "orderCode" -> leafTerms.map(typeSignatureOf(_)).mkString(",\n"),

        "namespace" -> namespace
      ).newline
    }
    def buildXSchema() = {
      code.add("public static var xschema: JValue = ${json};",
        "json" -> renderHaXe(definition.serialize)
      )
    }

    buildDocumentationFor(definition.properties, code)

    val definitionTraits = database.coproductContainersOf(definition).map { x => typeSignatureOf(x.referenceTo) } ::: extractListProperty(definition.properties, "haxe.class.traits")

    val rootCoproduct = findRootCoproduct(definition)
    val name = if (definition.name.startsWith("_")) "A" + definition.name else definition.name
    code.using("type" -> typeSignatureOf(definition.referenceTo), "name" -> name, "ancestor" -> rootCoproduct) {
      definition match {
        case x: XProduct =>
          var classDefinition = if (x.isSingleton) Tuple2("AbstractSingletonDataObject<${ancestor}>", "")
                                else Tuple2("AbstractDataObject<${ancestor}>", """
                                            public function decompose(): JValue {
                                              return JObject([${decomposerCode}]);
                                            }
                                          """)

          code.add("""@DataClass
          class ${name} ${extendsClause}""",
            "extendsClause" -> formCompleteExtensionClause(Some(classDefinition._1), definitionTraits)
          ).block {
            code.add("""
              public static function extract(v: JValue): ${type} {
                return new ${type}(${extractorCode});
              }""" + classDefinition._2
              ,
              "decomposerCode" -> (x.realFields.map { field =>
                "JField('" + field.name + "', " + getDecomposerFor(field.fieldType) + "(" + fieldNameOf(field.name) + ")" + ")"
              }).mkString(", "),

              "extractorCode" -> (x.realFields.map { field =>
                "v.extractFieldValue('" + field.name + "', " + getExtractorFor(field.fieldType) + ", " + renderHaXe(field.default) + ")"
              }).mkString(", ")
            ).newline
            // Build fields:
            var index = -1;
            code.join(x.terms, code.newline) { field => {
                val fieldAnnotation = field match{
                  case e: XRealField => e.order match {
                    case XOrderAscending  =>
                      index = index + 1
                      "@DataField({order : FieldOrder.Ascending, index : %d, equalsHash : true, show : true})".format(index)
                    case XOrderDescending =>
                      index = index + 1
                      "@DataField({order : FieldOrder.Descending, index : %d, equalsHash : true, show : true})".format(index)
                    case XOrderIgnore     => "@DataField({order : FieldOrder.Ignore, equalsHash : true, show : true})"
                  }
                  case _ => "@DataField({order : FieldOrder.Ignore, equalsHash : false, show : false})"
                }
                code.add(fieldAnnotation + "\n" +
                  """public var ${fieldName} (default, null): ${fieldType};""",
                  "fieldName" -> fieldNameOf(field.name),
                  "fieldType" -> typeSignatureOf(field.fieldType)
                )
              }
            }

            if (x.isSingleton) {
              code.newline(2).addln("public static var Instance: ${type} = new ${type}();");
            }

            val argsList = x.realFields.map { f => fieldNameOf(f.name) }.mkString(", ")
            val constructorArgs = (x.realFields.map { f =>
              fieldNameOf(f.name) + ": " + typeSignatureOf(f.fieldType)
            }).mkString(", ")

            val orderFunction =  if (rootCoproduct == typeSignatureOf(x.referenceTo)) "" else "${ancestor}Extensions.compare"

            // Build constructor:
            code.newline.add("public function new(${constructorArgs}) ", "constructorArgs" -> constructorArgs).block {
              code.add("super(${orderFunction});", "orderFunction" -> orderFunction)
              code.join(x.terms, code.newline) { field =>
                code.using("fieldName" -> fieldNameOf(field.name), "fieldType" -> typeSignatureOf(field.fieldType)) {
                  code.add("this.${fieldName} = ${fieldValue};",
                    "fieldValue" -> (field match {
                      case x: XRealField => "${fieldName}"

                      case x: XViewField =>
                        val product = database.resolve(field.fieldType).asInstanceOf[XProduct]

                        "new ${fieldType}(" + product.realFields.map { f => fieldNameOf(f.name) }.mkString(", ") + ")"

                      case x: XConstantField => getExtractorFor(x.fieldType) + "(" + renderHaXe(x.default) + ")"
                    })
                  );
                }
              }
            }
          }

        case x: XCoproduct =>
//          val x = XCoproduct(name, y.namespace, y.properties, y.terms, y.default)
          code.add("interface ${name} ${extendsClause}", "extendsClause" -> formCompleteExtensionClause(None, definitionTraits)).block {
            code.join(database.commonFieldsOf(x), code.newline) { common =>
              code.add("public var ${fieldName} (default, null): ${fieldType};",
                "fieldName" -> common._1,
                "fieldType" -> typeSignatureOf(common._2)
              )
            }
          }

          code.newline(2).add("class ${name}Extensions ").block {
            buildMultitypeTypeclasses(x)
          }

          case x: XUnion =>
            // HaXe has no clean representation for union types yet, so we just
            // use a typedef to Dynamic:
            code.add("typedef ${name} = Dynamic")

            code.newline(2).add("class ${name}Extensions ").block {
              buildMultitypeTypeclasses(x)
            }
      }
    }
  }

  private def buildDocumentationFor(properties: Map[String, JValue], code: CodeBuilder): Unit = properties.get(PredefinedProperties.XSchemaDoc) match {
    case None =>
    case Some(v) => v match {
      case JString(doc) => code.add("/** ").wrap(doc.replaceAll("\\s+", " "), " * ", 80).newline.add(" */").newline
      case x => error("Expected string for documentation, but found: " + x)
    }
  }

  def getTypeHintFor(ref: XReference, escapeClassName: Boolean): String = ref match {
    case x: XPrimitiveRef => x match {
      case XString  => "String"
      case XInt     => "Int"
      case XLong    => "Int"
      case XFloat   => "Float"
      case XDouble  => "Float"
      case XBoolean => "Bool"
      case XJSON    => "JValue"
      case XDate    => "Date"
    }

    case x: XContainerRef => x match {
      case x: XCollection => x match {
        case x: XSet   => "Set"
        case x: XList  => "List"
        case x: XArray => "Array"
      }

      case x: XMap      => "Map"
      case x: XTuple    => "Tuple" + x.types.length
      case x: XOptional => "Option"
    }

    case x: XDefinitionRef => if (escapeClassName) escapeHaXeClassName(x.name) else x.name
  }

  def getValueTypeHintFor(ref: XReference): String = ref match {
    case x: XPrimitiveRef => x match {
      case XString  => "TClass(String)"
      case XInt     => "TInt"
      case XLong    => "TInt"
      case XFloat   => "TFloat"
      case XDouble  => "TFloat"
      case XBoolean => "TBool"
      case XJSON    => "TEnum(haxe.text.json.JValue)"
      case XDate    => "TClass(Date)"
    }

    case x: XContainerRef => x match {
      case x: XCollection => x match {
        case x: XSet   => "TClass(Set)"
        case x: XList  => "TClass(List)"
        case x: XArray => "TClass(Array)"
      }

      case x: XMap      => "TClass(Map)"
      case x: XTuple    => "TClass(Tuple" + x.types.length + ")"
      case x: XOptional => "TEnum(Option)"
    }

    case x: XDefinitionRef => "TClass(" + x.name + ")"
  }


  private def getDecomposerFor(ref: XReference)(implicit database: XSchemaDatabase): String = {
    ref match {
      case x: XMap if (x.keyType == XString) => "MapExtensions.stringKeyDecompose"
      case x: XDefinitionRef => database.resolve(x) match {
        case t : XMultitype =>
          var classname = x.namespace + "." + getTypeHintFor(x, true);
          classname + "Extensions.decompose"
        case _ => "TranscodeJValue.getDecomposerFor(" + getValueTypeHintFor(ref) + ")"
      }
      case _  => "TranscodeJValue.getDecomposerFor(" + getValueTypeHintFor(ref) + ")"
    }
  }

  private def getExtractorFor(ref: XReference)(implicit database: XSchemaDatabase): String = {
    def defaultExtractor(args: String) = "TranscodeJValue.getExtractorFor(" + getValueTypeHintFor(ref) + ", " + args + ")";

    ref match {
      case x: XMap if (x.keyType == XString) => "function(v){return MapExtensions.stringKeyExtract(v, " + getExtractorFor(x.valueType) + getExtractorFunctions(x.valueType) + ");}"
      case x: XSet  => defaultExtractor("[" + getExtractorFor(x.elementType) + getExtractorFunctions(x.elementType) + "]")
      case x: XList => defaultExtractor("[" + getExtractorFor(x.elementType) + getExtractorFunctions(x.elementType) + "]")
      case x: XMap  => defaultExtractor("[" + getExtractorFor(x.keyType) + ", " + getExtractorFor(x.valueType) + getExtractorFunctions(x.keyType) + getExtractorFunctions(x.valueType) + "]")
      case x: XPrimitiveRef  => defaultExtractor("[]")

      case x: XContainerRef => (x match {
        case x: XArray      => defaultExtractor("[" + getExtractorFor(x.elementType) + "]")
        case x: XTuple      => defaultExtractor(x.types.map(getExtractorFor _).mkString("[", ", ", "]"))
        case x: XOptional   => defaultExtractor("[" + getExtractorFor(x.optionalType) + "]")
        case _ => error("Impossible")
      })

      case x: XDefinitionRef => database.resolve(x) match {
        case t : XMultitype =>
          var classname = x.namespace + "." + getTypeHintFor(x, true);
          classname + "Extensions.extract"
        case _ => defaultExtractor("[]")
      }
    }
  }

  private def findRootCoproduct(definition: XDefinition)(implicit database: XSchemaDatabase) = {
    def coproducts(defns: List[XDefinition]) = {
      val parents       = defns.map(database.coproductContainersOf(_))
      parents.tail.foldLeft(parents.head){ (l, p) => l.union(p)}
    }

    var coproductsList = definition :: Nil
    while(coproducts(coproductsList).size > 0){
      coproductsList = coproducts(coproductsList)
    }
    val coproductsTypes = coproductsList.map{ x => typeSignatureOf(x.referenceTo) }
    if (coproductsTypes.size != 1){
      throw new RuntimeException("More then one root coproducts found for %s. Coproducts: %s.".format(typeSignatureOf(definition.referenceTo), coproductsTypes.mkString(", ")) )
    }
    coproductsTypes.head
  }

  private def getExtractorFunctions(ref: XReference)(implicit database: XSchemaDatabase) = ref match{
    case x: XDefinitionRef => database.resolve(x) match {
      case t : XMultitype =>
        val classname = x.namespace + "." + getTypeHintFor(x, true) + "Extensions";
        val functions = classname + ".compare" :: classname + ".equals" :: classname + ".hashCode" :: classname + ".toString" :: Nil
        functions.mkString(", ", ", ", "")
      case _ => ""
    }
    case _ => ""
  }

  private def buildConstantsFor(namespace: String, code: CodeBuilder)(implicit database: XSchemaDatabase): Unit = {
    code.newline(2).add("class Constants ").block {
      code.join(database.constantsIn(namespace), code.newline(2)) { constant =>
        buildDocumentationFor(constant.properties, code)

        code.add("public static var ${name}: ${type} = ${extractor}(${json});",
          "name"      -> constant.name,
          "json"      -> renderHaXe(constant.default),
          "type"      -> typeSignatureOf(constant.constantType),
          "extractor" -> getExtractorFor(constant.constantType)
        )
      }
    }
  }

  private def renderHaXe(jvalue: JValue): String = {
    def escapeHaXeString(s: String): String = {
      val buf = new StringBuilder
      for (i <- 0 until s.length) {
        val c = s.charAt(i)
        buf.append(c match {
          case '"'  => "\\\""
          case '\\' => "\\\\"
          case '\b' => "\\b"
          case '\f' => "\\f"
          case '\n' => "\\n"
          case '\r' => "\\r"
          case '\t' => "\\t"
          case c if ((c >= '\u0000' && c < '\u001f') || (c >= '\u0080' && c < '\u00a0') || (c >= '\u2000' && c < '\u2100')) => "\\u%04x".format(c: Int)
          case c => c
        })
      }
      buf.toString
    }

    jvalue match {
      case JNothing     => "JNull"
      case JNull        => "JNull"
      case JString(v)   => "JString('" + escapeHaXeString(v) + "')"
      case JBool(v)     => "JBool(" + v + ")"
      case JInt(v)      => "JNumber(" + v + ")"
      case JDouble(v)   => "JNumber(" + v + ")"
      case JArray(v)    => "JArray([" + v.map(renderHaXe).mkString(", ") + "])"
      case JObject(v)   => "JObject([" + v.map(renderHaXe).mkString(", ") + "])"
      case JField(k, v) => "JField('" + escapeHaXeString(k) + "', " + renderHaXe(v) + ")"
    }
  }

  private def escapeHaXeClassName(name: String) = {
    if (name.startsWith("_")) "A" + name else name
  }

  private def fieldNameOf(name: String) = {
    val haXeKeywords = "default, case, function, callback, return, break, continue, typedef, package, class, interface, public, private, static, new, null, import, using, switch, if, else, while, for, in, var"

    haXeKeywords.split("\\s*,\\s*").toList.find(_ == name).map(_ + "Value").getOrElse(name)
  }

  private def typeSignatureOf(x: XReference)(implicit database: XSchemaDatabase): String = walk(x, CodeBuilder.empty, typeSignatureWalker(database)).code

  private def typeSignatureWalker(implicit database: XSchemaDatabase) = new XSchemaWalker[CodeBuilder] {
    override def begin(data: CodeBuilder, opt: XOptional) = {
      data += "Option<"
    }

    override def begin(data: CodeBuilder, col: XCollection) = {
      data += ((col match {
        case x: XSet   => "Set"
        case x: XArray => "Array"
        case x: XList  => "List"
      }) + "<")
    }

    override def begin(data: CodeBuilder, map: XMap) = {
      data += "Map<"
    }

    override def begin(data: CodeBuilder, tuple: XTuple) = {
      data += "Tuple" + tuple.types.length + "<"
    }

    override def separator(data: CodeBuilder) = data.add(", ")

    override def walk(data: CodeBuilder, prim: XPrimitiveRef) = {
      data += (prim match {
        case XString  => "String"
        case XInt     => "Int"
        case XLong    => "Int"
        case XFloat   => "Float"
        case XDouble  => "Float"
        case XBoolean => "Bool"
        case XJSON    => "JValue"
        case XDate    => "Date"
      })
    }

    override def walk(data: CodeBuilder, defn: XDefinitionRef) = {
      data += defn.namespace + "." + escapeHaXeClassName(defn.name)
    }

    override def end(data: CodeBuilder, opt: XOptional) = {
      data += ">"
    }

    override def end(data: CodeBuilder, col: XCollection) = {
      data += ">"
    }

    override def end(data: CodeBuilder, map: XMap) = {
      data += ">"
    }

    override def end(data: CodeBuilder, tuple: XTuple) = {
      data += ">"
    }
  }
}
