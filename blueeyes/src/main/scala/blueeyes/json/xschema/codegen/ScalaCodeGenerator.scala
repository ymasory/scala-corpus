package blueeyes.json.xschema.codegen

import _root_.blueeyes.json.JsonParser
import _root_.blueeyes.json.JsonAST._
import _root_.blueeyes.json.Printer._
import _root_.blueeyes.json.xschema._
import _root_.blueeyes.json.xschema.XSchemaTree._
import _root_.blueeyes.json.xschema.Serialization._

import java.io.{Writer}


object ScalaCodeGenerator extends CodeGeneratorCLI {
  val generator = new BaseScalaCodeGenerator
}

class BaseScalaCodeGenerator extends CodeGenerator with CodeGeneratorHelpers {
  def generate(root: XRoot, destPathCode: String, destPathTests: String, namespaceSpec: List[String], writerF: String => Writer) = {
    val includeSchemas = extractBoolProperty(root.properties, PredefinedProperties.XSchemaIncludeSchemas, true)

    val bundle      = CodeBundle.empty
    val testBundle  = CodeBundle.empty
    val database    = XSchemaDatabase(root.definitions, root.constants)
    
    val namespaces  = (if (namespaceSpec.length == 0) database.namespaces else namespaceSpec)
    
    for (namespace <- namespaces) {
      val code = CodeBuilder.empty
      val test = CodeBuilder.empty

      buildCodeFor(namespace, code, root, database, includeSchemas)
      buildTestFor(namespace, test, root, database, includeSchemas)

      bundle += toFile(namespace, "Data", "scala")         -> code
      testBundle += toFile(namespace, "DataTest", "scala") -> test
    }

    bundle.create(destPathCode, writerF)
    testBundle.create(destPathTests, writerF)
  }
  
  private def extractBoolProperty(map: Map[String, JValue], prop: String, default: Boolean) = map.get(prop) match {
    case None => false
    case Some(v) => v match {
      case JBool(b) => b
      case x => error("Expected bool but found: " + x)
    }
  }
  
  private def extractListProperty(map: Map[String, JValue], prop: String): List[String] = map.get(prop) match {
    case None => Nil
    
    case Some(v) => v match {
      case JArray(list) => list.flatMap {
        case JString(s) => s :: Nil
        case x => error("Expected array of strings for " + prop + " property but found: " + x)
      }
      
      case JString(item) => item :: Nil
    
      case _ => error("Expected string or array of strings for " + prop + " property")
    }
  }
  
  private def buildCodeFor(namespace: String, code: CodeBuilder, root: XRoot, database: XSchemaDatabase, includeSchemas: Boolean): Unit = {
    code.addln("// This code was auto-generated by Lift Json XSchema - do not edit")
    
    code.add("package " + namespace + " ").block {
      code.addln("import blueeyes.json.JsonParser._").
           addln("import blueeyes.json.JsonAST._")
           
      if (namespace != "blueeyes.json.xschema") {
        code.addln("import blueeyes.json.xschema.{SerializationImplicits, Extractor, Decomposer}")
        
        if (includeSchemas) {
          code.addln("import blueeyes.json.xschema.{XRoot, XProduct, XCoproduct, XUnion}")
        }
      }
           
      // Do user-specified imports:
      extractListProperty(root.properties, "scala.imports").map("import " + _.trim) foreach { x => code.addln(x) }
      
      buildOrderingsFor(namespace, code, database)
      
      code.newline(2)
    
      // Unions are mapped to Any in Scala, so we only need to build data for coproducts and products:
      code.join(database.coproductsIn(namespace) ++ database.productsIn(namespace), code.newline.newline) { definition =>
        buildDataFor(definition, code, database, includeSchemas)
      }
    
      buildExtractorsFor(namespace, code, database)
      buildDecomposersFor(namespace, code, database)
      buildPackageObjectFor(namespace, code, database, root.properties, includeSchemas)
      
      buildConstantsFor(namespace, code, database)
    }
  }
  
  private def buildTestFor(namespace: String, code: CodeBuilder, root: XRoot, database: XSchemaDatabase, includeSchemas: Boolean): Unit = {
    code.addln("// These tests were auto-generated by Lift Json XSchema - do not edit")
    
    code.using("namespace" -> namespace) {
      code.add("package " + namespace + " ").block {
        code.add("""
          import _root_.org.specs.Specification
          import _root_.org.specs.runner.{Runner, JUnit}

          import blueeyes.json.JsonParser._
          import blueeyes.json.JsonAST._
          
          import blueeyes.json.xschema.DefaultSerialization._

          import ${namespace}.Serialization._
          import ${namespace}.Constants._
        """).newline
        
        code.add("import ${namespace}.{")
        
        code.join((database.coproductsIn(namespace) ++ database.productsIn(namespace)).map(_.name), code.add(", ")) { name =>
          code.add(name)
        }
        
        code.addln("}")
        
        buildSerializationTestFor(namespace, code, root, database, includeSchemas)
      }
    }
  }
  
  private def buildSerializationTestFor(namespace: String, code: CodeBuilder, root: XRoot, database: XSchemaDatabase, includeSchemas: Boolean): Unit = {
    // For every product we generate some test data constructed by 
    // deserializing the product from nothing:
    code.newline.add("object ExampleProductData ").block {
      code.join(database.productsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo, database), "extractor" -> getExtractorFor(defn.referenceTo)) {
          defn match { 
            case x: XProduct if (x.isSingleton) => 
              // Due to apparent bug in Scala compiler (implicits for singleton types), we must treat this case specially:
              code.add("lazy val Example${name}: ${type} = ${extractor}.extract(JObject(Nil))")
          
            case x: XProduct => 
              code.add("lazy val Example${name}: ${type} = JObject(Nil).deserialize[${type}]")
          }
        }
      }
    }
    
    // For every product, we test both serialization & deserialization (in basic ways):
    code.newline.addln("class DataProductSerializationTest extends Runner(DataProductSerializationExamples) with JUnit")
    
    code.add("object DataProductSerializationExamples extends Specification ").block {
      code.join(database.productsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo, database)) {
          code.add("""
            "Deserialization of ${name} succeeds even when information is missing" in {
              ExampleProductData.Example${name}.isInstanceOf[${type}] must be (true)
            }""").newline
          
          if (defn.isSingleton) {
            code.add("""
              "Serialization of ${name} has non-zero information content" in {
                Decomposers.${name}Decomposer.decompose(ExampleProductData.Example${name}) mustNot be (JObject(Nil))
              }""")
          }
          else {
            code.add("""
              "Serialization of ${name} has non-zero information content" in {
                ExampleProductData.Example${name}.serialize mustNot be (JObject(Nil))
              }
            """)
          }
        }
      }
    }
    
    // For every multitype, we generate some test data constructed by 
    // deserializing every product which is type-compatible with the multitype:
    code.newline.add("object ExampleMultitypeData ").block {
      code.join(database.coproductsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo, database)) {
          code.addln("""lazy val Example${name}: ${type} = JObject(Nil).deserialize[${type}]""")
          
          code.join(database.findProductTerms(defn), code.newline) { product =>   
            code.add("""lazy val Example${name}From${productName}: ${type} = JObject(JField("${productName}", ${productNamespace}.Decomposers.${productName}Decomposer.decompose(${productNamespace}.ExampleProductData.Example${productName})) :: Nil).deserialize[${type}]""",
              "productName"      -> product.name,
              "productNamespace" -> product.namespace
            )
          }
        }
      }
    }
    
    code.newline.addln("class DataCoproductSerializationTest extends Runner(DataCoproductSerializationExamples) with JUnit")
    
    code.add("object DataCoproductSerializationExamples extends Specification ").block {
      code.join(database.coproductsIn(namespace), code.newline.newline) { defn =>
        code.using("name" -> defn.name, "type" -> typeSignatureOf(defn.referenceTo, database)) {
          code.add("""
            "Deserialization of ${name} succeeds even when information is missing" in {
              ExampleMultitypeData.Example${name}.isInstanceOf[${type}] must be (true)
            }            
            "Serialization of ${name} has non-zero information content" in {
              ExampleMultitypeData.Example${name}.serialize mustNot be (JObject(Nil))
            }
          """).newline
          
          code.join(database.findProductTerms(defn), code.newline) { product =>   
            code.add("""
              "Deserialization of ${name} (from ${productName}) succeeds" in {
                ExampleMultitypeData.Example${name}From${productName}.isInstanceOf[${type}] must be (true)
              }            
              "Serialization of ${name} (from ${productName}) has non-zero information content" in {
                ExampleMultitypeData.Example${name}From${productName}.serialize mustNot be (JObject(Nil))
              }""",
              "productName" -> product.name
            )
          }
        }
      }
    }
    
    code.newline.addln("class DataConstantsSerializationTest extends Runner(DataConstantsSerializationExamples) with JUnit")
    
    code.add("object DataConstantsSerializationExamples extends Specification ").block {
      code.join(database.constantsIn(namespace), code.newline.newline) { constant => 
        code.add("""
          "Deserialization of constant ${name} succeeds" in {
            Constants.${name}.serialize.deserialize[${type}] must be (Constants.${name})
          }
          "Serialization of constant ${name} has non-zero information content" in {
            Constants.${name}.serialize mustNot be (JObject(Nil))
          }
        """,
        "name" -> constant.name,
        "type" -> typeSignatureOf(constant.constantType, database)
        )
      }
    }
  }
  
  private def formCompleteExtensionClause(traits: List[String]) = traits match {
    case Nil => ""
    case xs => "extends " + xs.mkString(" with ") + " "
  }
  
  private def buildDataFor(definition: XDefinition, code: CodeBuilder, database: XSchemaDatabase, includeSchemas: Boolean): Unit = {
    def coproductPrefix(x: XCoproduct): String = if (database.namespacesOf(x).distinct.length <= 1) "sealed " else ""
    def buildProductFields(x: XProduct): Unit = {
      code.add(x.realFields.map(x => x.name + ": " + typeSignatureOf(x.fieldType, database)).mkString(", "))
    }
    def buildCoproductFields(x: XCoproduct): Unit = {
      val commonFields = database.commonFieldsOf(x)
      
      code.join(commonFields, code.newline) { field =>
        code += ("def " + field._1 + ": " + typeSignatureOf(field._2, database))
      }
    }    
    def buildOrderedDefinition(x: XProduct): Unit = {
      code.add("def compare(that: ${typeSig}): Int = ${ordering}.compare(this, that)", 
        "ordering" -> getOrderingFor(x.referenceTo),
        "typeSig"  -> typeSignatureOf(x.referenceTo, database)
      )
    }
    def buildViewFields(x: XProduct): Unit = {
      code.join(x.viewFields, code.newline) { viewField =>
        database.resolve(viewField.fieldType) match {
          case product: XProduct => 
            code.using("fieldName" -> viewField.name, "typeSig" -> typeSignatureOf(viewField.fieldType, database)) {
              if (product.isSingleton) {
                error("View fields cannot be used for objects, constant fields should be used instead")
              }
              else {
                code.add("def ${fieldName}: ${typeSig} = ${typeSig}(${constructorArgs})",
                  "constructorArgs" -> product.realFields.map(_.name).mkString(", ")
                )
              }
            }
            
          case x => error("View type cannot be anything but product: " + x)
        }
      }
    }
    def buildConstantFields(x: XProduct): Unit = {
      code.join(x.constantFields, code.newline) { constantField =>
        val constantType = constantField.fieldType 
        
        code.add("lazy val ${fieldName}: ${typeSig} = ${extractor}.extract(${json})",
          "fieldName" -> constantField.name, 
          "typeSig"   -> typeSignatureOf(constantType, database),
          "extractor" -> getExtractorFor(constantType),
          "json"      -> compact(renderScala(constantField.default))
        )
      }
    }

    def buildXSchema() = {
      code.add("lazy val xschema: ${definitionType} = blueeyes.json.xschema.Extractors.XDefinitionExtractor.extract(${json}).asInstanceOf[${definitionType}]",
        "json"           -> compact(renderScala(definition.serialize)),
        "definitionType" -> definition.productPrefix
      )
    }
    
    buildDocumentationFor(definition.properties, code)
    
    val definitionTraits = database.coproductContainersOf(definition).map { x => typeSignatureOf(x.referenceTo, database) } ::: extractListProperty(definition.properties, "scala.class.traits")
    
    var isSingleton = definition match {
      case x: XProduct => x.isSingleton
      case _           => false
    }
    
    code.using("type" -> typeSignatureOf(definition.referenceTo, database), "name" -> definition.name) {
      definition match {
        case x: XProduct =>
          var initialExtends: List[String] = Nil
          
          if (isSingleton) {
            code.add("case object ${name} ")
            
            if (includeSchemas) {
              initialExtends = extractListProperty(definition.properties, "scala.object.traits")
            }
          }
          else {
            code.add("case class ${name}(")
            buildProductFields(x)
            code.add(") ")
            
            initialExtends = List("Ordered[${type}]")
          }
      
          val withClauses = initialExtends ::: definitionTraits
          
          code += formCompleteExtensionClause(withClauses)
          
          if (!isSingleton) {
            code.block {
              buildOrderedDefinition(x)
            
              code.newline
            
              buildViewFields(x)
            }
          }
          else if (includeSchemas) {
            code.block {
              buildXSchema()
              
              code.newline
              
              buildConstantFields(x)
            }
          }
      
        case x: XCoproduct => 
          val withClauses = "Product" :: definitionTraits
          
          code.add(coproductPrefix(x) + "trait ${name} ${extendsClause}", "extendsClause" -> formCompleteExtensionClause(withClauses)).block {
            buildCoproductFields(x)
          }
          
          case x: XUnion =>
            // Scala has no clean representation for union types; we don't generate any type for 
            // them, but rather use Any, in combination with custom extractors/decomposers/orderings
      }
      
      // **********
      val objectMixins = extractListProperty(definition.properties, "scala.object.traits")
      
      if (!isSingleton && (includeSchemas || objectMixins.length > 0)) {
        code.newline.add("object ${name} ${extendsClause}", "extendsClause" -> formCompleteExtensionClause(objectMixins)).block {
          if (includeSchemas) {
            buildXSchema()
          }
        }
      }
    }
  }
  
  private def buildDocumentationFor(properties: Map[String, JValue], code: CodeBuilder): Unit = properties.get(PredefinedProperties.XSchemaDoc) match {
    case None => 
    case Some(v) => v match {
      case JString(doc) => code.add("/** ").wrap(doc.replaceAll("\\s+", " "), " * ", 80).newline.add(" */").newline
      case x => error("Expected string for documentation, but found: " + x)
    }
  }
  
  def getTypeHintFor(ref: XReference): String = ref match {
    case x: XPrimitiveRef => x match {
      case XString  => "String"
      case XInt     => "Int"
      case XLong    => "Long"
      case XFloat   => "Float"
      case XDouble  => "Double"
      case XBoolean => "Boolean"
      case XJSON    => "JValue"
      case XDate    => "Date"
    }
    
    case x: XContainerRef => x match {
      case x: XCollection => x match {
        case x: XSet   => "Set"
        case x: XList  => "List"
        case x: XArray => "Array"
      }
      
      case x: XMap => "Map"
      case x: XTuple => "Tuple" + x.types.length
      case x: XOptional => "Option"
    }
    
    case x: XDefinitionRef => x.name
  }
  
  private def getExtractorFor(ref: XReference): String = {
    ref match {
      case x: XPrimitiveRef  => "blueeyes.json.xschema.DefaultExtractors." + getTypeHintFor(ref) + "Extractor"
      
      case x: XMap if (x.keyType == XString) => "blueeyes.json.xschema.DefaultExtractors.StringMapExtractor(" + getExtractorFor(x.valueType) + ")"

      case x: XContainerRef => "blueeyes.json.xschema.DefaultExtractors." + getTypeHintFor(ref) + "Extractor(" + (x match {
        case x: XCollection => getExtractorFor(x.elementType)      
        case x: XMap        => getExtractorFor(x.keyType) + ", " + getExtractorFor(x.valueType)
        case x: XTuple      => x.types.map(getExtractorFor _ ).mkString(", ")
        case x: XOptional   => getExtractorFor(x.optionalType)
      }) + ")"

      case x: XDefinitionRef => x.namespace + ".Extractors." + getTypeHintFor(x) + "Extractor"
    }
  }
  
  private def buildExtractorsFor(namespace: String, code: CodeBuilder, database: XSchemaDatabase): CodeBuilder = {    
    def buildMultitypeExtractor(multitype: XMultitype, terms: List[XReference]) = {
      code.using("typeHint" -> getTypeHintFor(multitype.referenceTo), "typeSig" -> typeSignatureOf(multitype.referenceTo, database)) {
        code.add("lazy val ${typeHint}ExtractorFunction: PartialFunction[JField, ${typeSig}] = (").block {
          code.join(terms, code.newline) { term =>
            code.add("""case JField("${typeHint}", value) => ${extractor}.extract(value)""",
              "extractor" -> getExtractorFor(term),
              "typeHint"  -> getTypeHintFor(term)
            )
          }
        }.add(": PartialFunction[JField, ${typeSig}])")
        
        val multitypeTerms = database.resolve(terms).filter(_.isInstanceOf[XCoproduct]).map(_.asInstanceOf[XCoproduct]).map(_.referenceTo)
        
        multitypeTerms.foreach { term =>
          code.add(".orElse(${extractorFunction})", "extractorFunction" -> (getExtractorFor(term) + "Function"))
        }
      
        code.newline.add("""
          ${implicitPrefix}val ${typeHint}Extractor: Extractor[${typeSig}] = new Extractor[${typeSig}] {
            def extract(jvalue: JValue): ${typeSig} = {
              def extract0(jvalue: JValue): Option[${typeSig}] = {
                (jvalue --> classOf[JObject]).fields.filter(${typeHint}ExtractorFunction.isDefinedAt _) match {
                  case field :: fields => Some(${typeHint}ExtractorFunction(field))
                  case Nil => None
                }
              }
              
              extract0(jvalue) match {
                case Some(v) => v
                case None => extract0(${defaultJValue}) match {
                  case Some(v) => v
                  case None => error("Expected to find ${typeSig}, but found " + jvalue + ", and default value was invalid")
                }
              }
            }
          }""", 
          "defaultJValue"  -> compact(renderScala(multitype.default)),
          "implicitPrefix" -> getImplicitPrefix(multitype)
        )
      }
    }
    
    code.newline(2).add("trait Extractors ").block {    
      code.add("""
        protected def extractField[T](jvalue: JValue, name: String, default: JValue, e: Extractor[T]): T = {
          try {
            e.extract((jvalue \ name) match { case JNothing => default; case jvalue => jvalue })
          }
          catch {
            case _ => e.extract(default)
          }
        }""").newline(2)
        
      code.join(database.definitionsIn(namespace), code.newline.newline) { definition =>
        definition match {
          case x: XProduct => 
            code.using("constructor" -> x.name, "typeHint" -> getTypeHintFor(x.referenceTo), "typeSig" -> typeSignatureOf(x.referenceTo, database)) {
              code.add("implicit val ${typeHint}Extractor: Extractor[${typeSig}] = new Extractor[${typeSig}] ").block {
                code.add("def extract(jvalue: JValue): ${typeSig} = ").block {
                  if (x.realFields.length == 0) {
                    code.add("${constructor}")
                  }
                  else {
                    code.add("${constructor}").paren {          
                      var isFirst = true

                      code.join(x.realFields, code.add(",").newline) { field =>
                        code.add("extractField[${fieldType}](jvalue, \"${fieldName}\", ${json}, ${fieldExtractor})",
                          "fieldType"      -> typeSignatureOf(field.fieldType, database),
                          "fieldName"      -> field.name,
                          "json"           -> compact(renderScala(field.default)),
                          "fieldExtractor" -> getExtractorFor(field.fieldType)
                        )
                      }
                    }
                  }
                }
              }
            }
          
          case x: XCoproduct =>
            buildMultitypeExtractor(x, x.terms)
            
          case x: XUnion =>
            buildMultitypeExtractor(x, x.terms)
        }
      }
    }
    code.newline.add("object Extractors extends Extractors")
  }
  
  private def getDecomposerFor(ref: XReference): String = ref match {
    case x: XPrimitiveRef => "blueeyes.json.xschema.DefaultDecomposers." + getTypeHintFor(ref) + "Decomposer"
    
    case x: XMap if (x.keyType == XString) => "blueeyes.json.xschema.DefaultDecomposers.StringMapDecomposer(" + getDecomposerFor(x.valueType) + ")"

    case x: XContainerRef => "blueeyes.json.xschema.DefaultDecomposers." + getTypeHintFor(ref) + "Decomposer(" + (x match {
      case x: XCollection => getDecomposerFor(x.elementType)              
      case x: XMap        => getDecomposerFor(x.keyType) + ", " + getDecomposerFor(x.valueType)      
      case x: XTuple      => x.types.map(getDecomposerFor _ ).mkString(", ")
      case x: XOptional   => getDecomposerFor(x.optionalType)
    }) + ")"

    case x: XDefinitionRef => x.namespace + ".Decomposers." + getTypeHintFor(x) + "Decomposer"
  }
  
  private def getImplicitPrefix(multitype: XMultitype): String = {
    multitype match {
      case _ : XCoproduct => "implicit "
      case _ : XUnion => ""
    }
  }
  
  private def buildDecomposersFor(namespace: String, code: CodeBuilder, database: XSchemaDatabase): Unit = {
    def buildMultitypeDecomposer(multitype: XMultitype, terms: List[XReference]) = {
      code.using("typeHint" -> multitype.name, "typeSig" -> typeSignatureOf(multitype.referenceTo, database)) {
        code.add("${implicitPrefix}val ${typeHint}Decomposer: Decomposer[${typeSig}] = new Decomposer[${typeSig}] ", "implicitPrefix" -> getImplicitPrefix(multitype)).block {
          code.add("def decompose(tvalue: ${typeSig}): JValue = ").block {
            code.add("tvalue match ").block {
              val expandedTerms = database.referencesOf(database.findLeafTerms(multitype)).distinct
              
              code.join(expandedTerms, code.newline) { term =>
                code.add("case x: ${termType} => JObject(JField(\"${typeHint}\", ${decomposer}.decompose(x)) :: Nil)",
                  "termType"   -> typeSignatureOf(term, database),
                  "typeHint"   -> getTypeHintFor(term),
                  "decomposer" -> getDecomposerFor(term)
                )
              }
            }
          }
        }
      }
    }
    
    code.newline(2).add("trait Decomposers ").block {    
      code.join(database.definitionsIn(namespace), code.newline.newline) { definition =>
        definition match {
          case x: XProduct => 
            code.using("typeHint" -> getTypeHintFor(x.referenceTo), "typeSig" -> typeSignatureOf(x.referenceTo, database)) {
              code.add("implicit val ${typeHint}Decomposer: Decomposer[${typeSig}] = new Decomposer[${typeSig}] ").block {
                code.add("def decompose(tvalue: ${typeSig}): JValue = ").block {
                  code.add("JObject").paren {  
                    code.join(x.realFields, code.newline) { field =>
                      code.add("JField(\"${fieldName}\", ${decomposer}.decompose(tvalue.${fieldName})) ::", 
                        "fieldName"  -> field.name,
                        "decomposer" -> getDecomposerFor(field.fieldType)
                      )
                    }
      
                    code.add(" Nil")
                  }
                }
              }
            }
        
          case x: XCoproduct => buildMultitypeDecomposer(x, x.terms)
          
          case x: XUnion => buildMultitypeDecomposer(x, x.terms)
        }
      }
    }
    code.newline.add("object Decomposers extends Decomposers")
  }
  
  private def buildConstantsFor(namespace: String, code: CodeBuilder, database: XSchemaDatabase): Unit = {
    code.newline(2).add("object Constants ").block {    
      code.addln("import Serialization._").newline
    
      code.join(database.constantsIn(namespace), code.newline) { constant =>
        buildDocumentationFor(constant.properties, code)
      
        code.add("lazy val ${name}: ${type} = ${extractor}.extract(${json})",
          "name"      -> constant.name,
          "json"      -> compact(renderScala(constant.default)),
          "type"      -> typeSignatureOf(constant.constantType, database),
          "extractor" -> getExtractorFor(constant.constantType)
        )
      }
    }
  }
  
  private def getOrderingFor(ref: XReference): String = ref match {
    case x: XPrimitiveRef  => "blueeyes.json.xschema.DefaultOrderings." + getTypeHintFor(ref) + "Ordering"

    case x: XContainerRef  => "blueeyes.json.xschema.DefaultOrderings." + getTypeHintFor(ref) + "Ordering(" + (x match {
      case x: XCollection => getOrderingFor(x.elementType)        
      case x: XMap        => getOrderingFor(x.keyType) + ", " + getOrderingFor(x.valueType)
      case x: XTuple      => x.types.map(getOrderingFor _ ).mkString(", ")
      case x: XOptional   => getOrderingFor(x.optionalType)
    }) + ")"

    case x: XDefinitionRef => x.namespace + ".Orderings." + getTypeHintFor(x) + "Ordering"
  }
  
  private def buildOrderingsFor(namespace: String, code: CodeBuilder, database: XSchemaDatabase): Unit = {    
    code.newline(2).add("trait Orderings ").block {
      code.join(database.definitionsIn(namespace), code.newline(2)) { defn => 
        code.using("typeHint" -> getTypeHintFor(defn.referenceTo), "typeSig" -> typeSignatureOf(defn.referenceTo, database)) {
          defn match {
            case product: XProduct =>
              code.add("""
                implicit val ${typeHint}Ordering: Ordering[${typeSig}] = new Ordering[${typeSig}] {
                  def compare(v1: ${typeSig}, v2: ${typeSig}): Int = {
                    import Stream.{cons, empty}

                    return if (v1 == v2) 0 else {      
                      val comparisons = ${comparisons}

                      comparisons.dropWhile(_ == 0).append(0 :: Nil).head
                    }
                  }
                }""",
                "comparisons" -> (product.realFields.reverse.filter(_.order != XOrderIgnore) match {
                  case Nil => "empty"

                  case head :: tail => 
                    def cmp(field: XRealField) = {
                      val name = field.name
                      val sign = field.order match {
                        case XOrderAscending  => "1"
                        case XOrderDescending => "-1"
                        case XOrderIgnore     => "0"
                      }

                      getOrderingFor(field.fieldType) + ".compare(v1." + name + ", v2." + name + ") * " + sign
                    }
                    def cons(head: String, tail: String) = "cons(" + head + ", " + tail + ")"

                    tail.foldLeft(cons(cmp(head), "empty")) { (comparisons, field) =>
                      cons(cmp(field), comparisons)
                    }
                })
              )
          
            case multitype: XMultitype =>
              val isUnion = multitype.isInstanceOf[XUnion]
              
              code.add("${implicitPrefix}val ${typeHint}Ordering: Ordering[${typeSig}] = new Ordering[${typeSig}] ", "implicitPrefix" -> getImplicitPrefix(multitype)).block {
                code.add("def compare(v1: ${typeSig}, v2: ${typeSig}): Int = ").block {
                  code.addln("if (v1 == v2) 0")
                  code.add("else v1 match ").block {
                    val multitypeTerms: List[XReference] = multitype match {
                      case x: XUnion     => x.terms
                      case x: XCoproduct => x.terms
                    }
                    
                    code.join(multitypeTerms, code.newline) { subtype1 => 
                      code.add("case x: ${subtype1} => v2 match ", "subtype1" -> typeSignatureOf(subtype1, database)).block {
                        code.join(multitypeTerms, code.newline) { subtype2 => 
                          val index1 = multitypeTerms.indexOf(subtype1)
                          val index2 = multitypeTerms.indexOf(subtype2)

                          val cmp = if (index1 < index2) "-1"
                                    else if (index2 < index1) "1"
                                    else getOrderingFor(subtype1) + ".compare(x, y)"

                          code.add("case y: ${subtype2} => " + cmp, "subtype2" -> typeSignatureOf(subtype2, database))
                        }
                      }
                    }
                  }
                }
              }
              
              if (!isUnion) {
                code.newline.add("case class Ordered${typeHint}(v1: ${typeSig}) extends Ordered[${typeSig}] ").block {
                  code.add("def compare(v2: ${typeSig}): Int = ${typeHint}Ordering.compare(v1, v2)")
                }
                code.newline.add("implicit def ${typeHint}ToOrdered${typeHint}(v: ${typeSig}) = Ordered${typeHint}(v)")
              }
          }
        }
      }
    }
    code.newline.add("object Orderings extends Orderings")
  }
  
  private def buildPackageObjectFor(namespace: String, code: CodeBuilder, database: XSchemaDatabase, properties: Map[String, JValue], includeSchemas: Boolean): Unit = {
    val subroot = XRoot(database.definitionsIn(namespace), database.constantsIn(namespace), properties)
    
    code.newline(2).add("object Serialization extends Decomposers with Extractors with SerializationImplicits ").block {
      // Storing the root as text is not efficient but ensures we do not run 
      // into method size limitations of the JVM (root can be quite large):
      if (includeSchemas) {
        code.add("lazy val xschema: XRoot = blueeyes.json.xschema.Extractors.XRootExtractor.extract(parse(\"\"\"" + compact(render(subroot.serialize)) + " \"\"\"))")
      }
    }
  }
  
  private def typeSignatureOf(x: XReference, database: XSchemaDatabase): String = walk(x, CodeBuilder.empty, typeSignatureWalker(database)).code
  
  private def typeSignatureWalker(database: XSchemaDatabase) = new XSchemaWalker[CodeBuilder] {
    override def begin(data: CodeBuilder, opt: XOptional) = {
      data += "Option["
    }
    
    override def begin(data: CodeBuilder, col: XCollection) = {
      data += ((col match {
        case x: XSet   => "Set"
        case x: XArray => "Array"
        case x: XList  => "List"
      }) + "[")
    }
    
    override def begin(data: CodeBuilder, map: XMap) = {
      data += "Map["
    }
    
    override def begin(data: CodeBuilder, tuple: XTuple) = {
      data += "("
    }
    
    override def separator(data: CodeBuilder) = data.add(", ")
    
    override def walk(data: CodeBuilder, prim: XPrimitiveRef) = {
      data += (prim match {
        case XString  => "String"
        case XInt     => "Int"
        case XLong    => "Long"
        case XFloat   => "Float"
        case XDouble  => "Double"
        case XBoolean => "Boolean"
        case XJSON    => "blueeyes.json.JsonAST.JValue"
        case XDate    => "java.util.Date"
      })
    }
    
    override def walk(data: CodeBuilder, defn: XDefinitionRef) = {
      database.resolve(defn) match {
        case x: XProduct =>
          if (x.isSingleton) {
            data += (defn.namespace + "." + defn.name + ".type")
          }
          else {
            data += (defn.namespace + "." + defn.name)
          }

        case x: XUnion => 
          val nonValuePrimitives = List(XJSON, XDate, XString)
          
          val valueTypes = x.terms.filter(_.isInstanceOf[XPrimitiveRef]).filter(x => !nonValuePrimitives.contains(x))
          
          val containsVals = valueTypes.length > 0
          val containsRefs = valueTypes.length < x.terms.length
          
          val allRefs = containsRefs && !containsVals
          val allVals = containsVals && !containsRefs
          
          data += (if (allRefs) "AnyRef" else if (allVals) "AnyVal" else "Any")
          
        case _ => data += (defn.namespace + "." + defn.name)
      }
    }
    
    override def end(data: CodeBuilder, opt: XOptional) = {
      data += "]"
    }
    
    override def end(data: CodeBuilder, col: XCollection) = {
      data += "]"
    }
    
    override def end(data: CodeBuilder, map: XMap) = {
      data += "]"
    }
    
    override def end(data: CodeBuilder, tuple: XTuple) = {
      data += ")"
    }
  }
}
